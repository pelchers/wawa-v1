# Component-API Syntax: Line-by-Line Explanation

This document provides a line-by-line explanation of how the likes functionality works, following the code flow from component to API and back.

## Function Prefix Conventions

Our codebase follows consistent naming conventions for functions that make their purpose immediately clear:

| Prefix | Purpose | Example | Description |
|--------|---------|---------|-------------|
| **`use`** | React hooks | `useAuth()` | Functions that start with "use" are React hooks. They follow React's rules of hooks (only call at top level, only call from React functions). Hooks can manage state, handle side effects, or encapsulate reusable logic. |
| **`handle`** | Event handlers | `handleLikeToggle()` | Functions that respond to user interactions like clicks, form submissions, or input changes. They typically process the event and update state or trigger other actions. |
| **`fetch`** | Data retrieval | `fetchPost()` | Functions that retrieve data from APIs. They typically return promises and are often used with async/await. |
| **`create`** | Resource creation | `createLike()` | Functions that create new resources, usually through API calls. They handle the creation process and often return the newly created resource. |
| **`update`** | Resource modification | `updatePost()` | Functions that modify existing resources, usually through API calls. They handle the update process and often return the updated resource. |
| **`delete`** | Resource removal | `deleteLike()` | Functions that remove resources, usually through API calls. They handle the deletion process and often return a success indicator. |
| **`get`** | Simple retrieval | `getAuthHeaders()` | Utility functions that retrieve or compute values without side effects. Unlike fetch functions, they typically work with local data rather than making API calls. |
| **`set`** | State updaters | `setLiked()` | Functions generated by React's useState hook that update a specific piece of state. They follow the pattern `set[StateName]`. |
| **`is`** | Boolean state | `isLoading` | State variables that represent boolean conditions. They follow the pattern `is[Condition]`. |
| **`on`** | Callback props | `onLikeChange` | Props that are callback functions passed from parent to child components. They follow the pattern `on[Event]`. |

These naming conventions help maintain consistency across the codebase and make it easier to understand what each function does at a glance.

## Frontend Flow

### 1. Heart Icon Component
**File: `client/src/components/icons/HeartIcon.tsx`**

```typescript
// Define the props interface for the HeartIcon component
interface HeartIconProps {
  filled?: boolean    // Whether the heart should be filled (liked) or outlined (not liked)
  className?: string  // CSS classes for styling
}

// Component definition with default prop values
export function HeartIcon({ filled = false, className = "" }: HeartIconProps) {
  // Conditional rendering based on the filled prop
  return filled ? (
    // Filled heart SVG - shown when content is liked
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      viewBox="0 0 24 24" 
      fill="currentColor"  // Uses the text color of the parent element
      className={className}
    >
      <path d="M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z" />
    </svg>
  ) : (
    // Outline heart SVG - shown when content is not liked
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      fill="none" 
      viewBox="0 0 24 24" 
      strokeWidth={1.5} 
      stroke="currentColor"  // Uses the text color of the parent element
      className={className}
    >
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z" />
    </svg>
  )
}
```

#### Detailed Explanation of HeartIcon Component Syntax:

1. **Interface Definition**:
   ```typescript
   interface HeartIconProps {
     filled?: boolean
     className?: string
   }
   ```
   - This creates a TypeScript interface that defines the shape of props the component accepts
   - The `?` symbol makes both properties optional (not required when using the component)
   - `filled?: boolean` - Optional boolean prop that determines if heart is filled or outlined
   - `className?: string` - Optional string prop for custom CSS classes

2. **Component Function Declaration**:
   ```typescript
   export function HeartIcon({ filled = false, className = "" }: HeartIconProps) {
   ```
   - `export function` - Makes the component available for import in other files
   - `HeartIcon` - The name of the component (PascalCase as per React convention)
   - `{ filled = false, className = "" }` - Destructuring the props object with default values:
     - If `filled` isn't provided, it defaults to `false`
     - If `className` isn't provided, it defaults to an empty string `""`
   - `: HeartIconProps` - TypeScript type annotation specifying this function accepts props matching the HeartIconProps interface

3. **Conditional Rendering with Ternary Operator**:
   ```typescript
   return filled ? (
     // Filled SVG
   ) : (
     // Outlined SVG
   )
   ```
   - The ternary operator (`condition ? trueResult : falseResult`) determines which SVG to render
   - If `filled` is true, returns the filled heart SVG
   - If `filled` is false, returns the outlined heart SVG

4. **SVG Element Properties**:
   ```typescript
   <svg 
     xmlns="http://www.w3.org/2000/svg" 
     viewBox="0 0 24 24" 
     fill="currentColor"
     className={className}
   >
   ```
   - Standard SVG attributes like `xmlns` and `viewBox` define the SVG properties
   - `fill="currentColor"` - Uses the current text color from CSS (inherits from parent)
   - `className={className}` - Passes through any custom CSS classes from props
   - The curly braces `{}` are used for embedding JavaScript expressions in JSX

5. **Path Element**:
   - Contains the SVG path data that defines the actual heart shape
   - Different between the filled and outlined versions

6. **Usage Example**:
   ```jsx
   // Default (outlined heart)
   <HeartIcon />
   
   // Filled heart
   <HeartIcon filled={true} />
   
   // With custom CSS class
   <HeartIcon className="w-6 h-6 text-red-500" />
   
   // Both filled and with custom class
   <HeartIcon filled={true} className="w-6 h-6 text-red-500" />
   ```

### 2. Like Button Component
**File: `client/src/components/buttons/LikeButton.tsx`**

```typescript
import { useState } from "react"  // React hook for local state management
import { HeartIcon } from "@/components/icons/HeartIcon"  // Import the heart icon component
import { likeEntity, unlikeEntity } from "@/api/likes"  // Import API functions for like operations

// Define the props interface for the LikeButton component
interface LikeButtonProps {
  entityType: string  // Type of content being liked (post, article, project, etc.)
  entityId: string    // Unique identifier for the content
  initialLikeCount: number  // Starting count of likes
  initialLiked: boolean     // Whether the current user has already liked this content
  size?: "sm" | "md" | "lg"  // Optional size variant
  variant?: "card" | "page"  // Optional display variant (for different contexts)
  className?: string         // Additional CSS classes
  onLikeChange?: (liked: boolean) => void  // Optional callback for parent components
}

// Component definition with default prop values
export default function LikeButton({
  entityType,
  entityId,
  initialLikeCount,
  initialLiked,
  size = "md",
  variant = "card",
  className = "",
  onLikeChange
}: LikeButtonProps) {
  // Local state management
  const [liked, setLiked] = useState(initialLiked)  // Track liked status
  const [likeCount, setLikeCount] = useState(initialLikeCount)  // Track like count
  const [isLoading, setIsLoading] = useState(false)  // Track loading state during API calls
  
  // Handler function for like/unlike button click
  const handleLikeToggle = async () => {
    if (isLoading) return  // Prevent multiple clicks during API call
    
    setIsLoading(true)  // Set loading state to prevent additional clicks
    
    // Optimistic update - update UI immediately before API call completes
    setLiked(!liked)  // Toggle liked state
    setLikeCount(prev => !liked ? prev + 1 : Math.max(0, prev - 1))  // Update count
    
    try {
      // Make the appropriate API call based on current state
      if (liked) {
        // If currently liked, unlike it
        await unlikeEntity(entityType, entityId)  // Call API function from likes.ts
      } else {
        // If not currently liked, like it
        await likeEntity(entityType, entityId)  // Call API function from likes.ts
      }
      
      // Notify parent component if callback provided
      if (onLikeChange) {
        onLikeChange(!liked)  // Pass the new liked state to parent
      }
    } catch (error) {
      console.error('Error toggling like:', error)
      // Revert optimistic update if there's an error
      setLiked(liked)  // Revert to original liked state
      setLikeCount(prev => liked ? prev + 1 : Math.max(0, prev - 1))  // Revert count
    } finally {
      setIsLoading(false)  // Reset loading state regardless of success/failure
    }
  }
  
  // Determine size-based classes for consistent styling
  const sizeClasses = {
    sm: "text-xs",
    md: "text-sm",
    lg: "text-base"
  }[size]

  // Determine variant-based classes for different contexts
  const variantClasses = {
    card: "gap-1",  // Less spacing for card view
    page: "gap-2"   // More spacing for page view
  }[variant]

  // Render the button with appropriate styling and behavior
  return (
    <button
      onClick={handleLikeToggle}  // Attach click handler
      disabled={isLoading}        // Disable during API calls
      className={`flex items-center ${sizeClasses} ${variantClasses} ${
        liked ? 'text-red-500' : 'text-gray-500 hover:text-red-400'
      } transition-colors ${className}`}  // Dynamic classes based on state
      aria-label={liked ? "Unlike" : "Like"}  // Accessibility label
      title={liked ? "Unlike" : "Like"}       // Tooltip text
    >
      <HeartIcon 
        filled={liked}  // Pass liked state to heart icon
        className={size === "lg" ? "w-5 h-5" : "w-4 h-4"}  // Size based on prop
      />
      <span>{likeCount}</span>  // Display the like count
    </button>
  )
}
```

#### Detailed Explanation of LikeButton Component:

1. **Imports**:
   ```typescript
   import { useState } from "react"
   import { HeartIcon } from "@/components/icons/HeartIcon"
   import { likeEntity, unlikeEntity } from "@/api/likes"
   ```
   - `useState` - React hook for creating and updating component state
   - `HeartIcon` - Our custom icon component we defined earlier
   - `likeEntity/unlikeEntity` - API functions that make HTTP requests to our backend

2. **Props Interface Definition**:
   ```typescript
   interface LikeButtonProps {
     entityType: string
     entityId: string
     initialLikeCount: number
     initialLiked: boolean
     size?: "sm" | "md" | "lg"
     variant?: "card" | "page"
     className?: string
     onLikeChange?: (liked: boolean) => void
   }
   ```
   - Defines the shape of props the component accepts
   - Required props: `entityType`, `entityId`, `initialLikeCount`, `initialLiked`
   - Optional props (with `?`): `size`, `variant`, `className`, `onLikeChange`
   - TypeScript union types (`"sm" | "md" | "lg"`) restrict values to specific options
   - Function type for callback: `(liked: boolean) => void`

3. **Component Function Declaration**:
   ```typescript
   export default function LikeButton({
     entityType,
     entityId,
     initialLikeCount,
     initialLiked,
     size = "md",
     variant = "card",
     className = "",
     onLikeChange
   }: LikeButtonProps) {
   ```
   - `export default function` - Makes this the default export from the file
   - Props destructuring with default values for optional props
   - Type annotation ensures props match the interface

4. **State Initialization**:
   ```typescript
   const [liked, setLiked] = useState(initialLiked)
   const [likeCount, setLikeCount] = useState(initialLikeCount)
   const [isLoading, setIsLoading] = useState(false)
   ```
   - Three state variables with their setter functions
   - Initial values come from props or defaults
   - Each state serves a specific purpose (tracking like status, count, and loading state)

5. **Event Handler Function**:
   ```typescript
   const handleLikeToggle = async () => {
     // Function body...
   }
   ```
   - `async` function allows using `await` for API calls
   - Handles the entire like/unlike flow including optimistic updates and error handling

6. **Optimistic UI Update Pattern**:
   ```typescript
   setLiked(!liked)
   setLikeCount(prev => !liked ? prev + 1 : Math.max(0, prev - 1))
   ```
   - Updates UI immediately before API call completes
   - Uses functional update pattern with previous state (`prev =>`)
   - `Math.max(0, prev - 1)` prevents negative counts

7. **Try/Catch/Finally Pattern**:
   ```typescript
   try {
     // API calls
   } catch (error) {
     // Error handling and UI reversion
   } finally {
     // Cleanup regardless of success/failure
   }
   ```
   - Robust error handling pattern
   - `finally` block ensures loading state is reset even if errors occur

8. **Dynamic Styling with Object Lookup**:
   ```typescript
   const sizeClasses = {
     sm: "text-xs",
     md: "text-sm",
     lg: "text-base"
   }[size]
   ```
   - Uses object lookup pattern to map prop values to CSS classes
   - More maintainable than multiple if/else statements
   - Ensures only valid values are used

9. **JSX Return with Conditional Classes**:
   ```typescript
   return (
     <button
       className={`flex items-center ${sizeClasses} ${variantClasses} ${
         liked ? 'text-red-500' : 'text-gray-500 hover:text-red-400'
       } transition-colors ${className}`}
       // Other props...
     >
       // Button content...
     </button>
   )
   ```
   - Template literals for dynamic class composition
   - Ternary operator for conditional styling based on state
   - Passes through custom `className` from props

10. **Accessibility Attributes**:
    ```typescript
    aria-label={liked ? "Unlike" : "Like"}
    title={liked ? "Unlike" : "Like"}
    ```
    - Dynamic accessibility attributes based on current state
    - Improves usability for screen readers and shows tooltips on hover

This component demonstrates several React best practices:
- Controlled component pattern with props and state
- Optimistic UI updates for better user experience
- Proper TypeScript typing for props and state
- Flexible styling with variant props and className forwarding
- Error handling with graceful UI recovery
- Parent communication through callback props

### 3. API Service
**File: `client/src/api/likes.ts`**

```typescript
import axios from 'axios'  // HTTP client for making API requests
import { getAuthHeaders } from '@/utils/auth'  // Helper to get authentication headers

// API base URL from environment variables or default
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:4100/api'

/**
 * Add a like to an entity
 */
export const likeEntity = async (entityType: string, entityId: string) => {
  try {
    // Make POST request to backend API
    const response = await axios.post(`${API_URL}/likes`, {
      entity_type: entityType,  // Send entity type to backend
      entity_id: entityId       // Send entity ID to backend
    }, {
      headers: getAuthHeaders()  // Include auth token in request headers
    })
    return response.data  // Return the response data to the component
  } catch (error) {
    console.error(`Error liking ${entityType}:`, error)  // Log error for debugging
    throw error  // Re-throw to allow component to handle the error
  }
}

/**
 * Remove a like from an entity
 */
export const unlikeEntity = async (entityType: string, entityId: string) => {
  try {
    // Make DELETE request to backend API
    const response = await axios.delete(`${API_URL}/likes`, {
      data: {  // For DELETE requests, data goes in the 'data' property
        entity_type: entityType,
        entity_id: entityId
      },
      headers: getAuthHeaders()  // Include auth token in request headers
    })
    return response.data  // Return the response data to the component
  } catch (error) {
    console.error(`Error unliking ${entityType}:`, error)  // Log error for debugging
    throw error  // Re-throw to allow component to handle the error
  }
}

/**
 * Check if the current user has liked an entity
 */
export const checkLikeStatus = async (entityType: string, entityId: string) => {
  try {
    // Make GET request to backend API
    const response = await axios.get(
      `${API_URL}/likes/status?entity_type=${entityType}&entity_id=${entityId}`,
      { headers: getAuthHeaders() }  // Include auth token in request headers
    )
    return response.data.liked  // Return just the liked boolean value
  } catch (error) {
    console.error(`Error checking like status for ${entityType}:`, error)
    return false  // Default to not liked if there's an error
  }
}

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (entityType: string, entityId: string) => {
  try {
    // Make GET request to backend API (no auth required for this endpoint)
    const response = await axios.get(
      `${API_URL}/likes/count?entity_type=${entityType}&entity_id=${entityId}`
    )
    return response.data.count  // Return just the count number
  } catch (error) {
    console.error(`Error getting like count for ${entityType}:`, error)
    return 0  // Default to 0 if there's an error
  }
}
```

#### Detailed Explanation of API Service Functions:

1. **Imports and Setup**:
   ```typescript
   import axios from 'axios'
   import { getAuthHeaders } from '@/utils/auth'
   
   const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:4100/api'
   ```
   - `axios` - Popular HTTP client library for making API requests
   - `getAuthHeaders` - Utility function that retrieves authentication headers
   - `API_URL` - Environment variable with fallback for local development

2. **Like Entity Function**:
   ```typescript
   export const likeEntity = async (entityType: string, entityId: string) => {
     // Function implementation...
   }
   ```
   - `async` function that returns a Promise
   - Takes entity type and ID as parameters
   - Uses try/catch for error handling
   - Makes POST request to create a new like

3. **Unlike Entity Function**:
   ```typescript
   export const unlikeEntity = async (entityType: string, entityId: string) => {
     // Function implementation...
   }
   ```
   - Similar structure to likeEntity but uses DELETE method
   - Note that axios DELETE requires data in a `data` property
   - Same parameters and error handling pattern

4. **Check Like Status Function**:
   ```typescript
   export const checkLikeStatus = async (entityType: string, entityId: string) => {
     // Function implementation...
   }
   ```
   - Makes GET request with query parameters
   - Returns boolean value from response
   - Returns false on error (graceful degradation)

5. **Get Like Count Function**:
   ```typescript
   export const getLikeCount = async (entityType: string, entityId: string) => {
     // Function implementation...
   }
   ```
   - Public endpoint (no auth headers required)
   - Returns numeric count from response
   - Returns 0 on error (graceful degradation)

6. **Error Handling Pattern**:
   ```typescript
   try {
     // API request
   } catch (error) {
     console.error(`Error message:`, error)
     throw error // or return default value
   }
   ```
   - Consistent error handling across all functions
   - Logs errors for debugging
   - Either re-throws (for component to handle) or returns sensible default

These API service functions demonstrate several best practices:
- Centralized API communication
- Consistent error handling
- Authentication header inclusion
- Graceful degradation with sensible defaults
- Clear function naming and documentation

### 4. Batch Hooks
**File: `client/src/hooks/batchHooks.ts`**

```typescript
import { useState, useEffect } from 'react'  // React hooks for state and side effects
import { checkLikeStatus } from '@/api/likes'  // Import API function for checking like status
import { useAuth } from '@/hooks/useAuth'  // Custom hook for authentication state

/**
 * Hook to check like status for multiple entities at once
 * Used in list views to efficiently fetch like status for many items
 */
export function useBatchLikeStatus(items: any[], entityType: string) {
  // State to store like status for each item by ID
  const [likeStatuses, setLikeStatuses] = useState<Record<string, boolean>>({})
  const [loading, setLoading] = useState(true)  // Track loading state
  const { isAuthenticated } = useAuth()  // Get authentication status
  
  // Effect runs when items, entityType, or auth status changes
  useEffect(() => {
    // Reset statuses when items change
    setLikeStatuses({})
    
    // Skip API calls if user is not authenticated or no items
    if (!isAuthenticated || !items.length) {
      setLoading(false)
      return
    }
    
    setLoading(true)
    
    // Create an array of promises, one for each item
    const promises = items.map(item => 
      checkLikeStatus(entityType, item.id)  // Call API for each item
        .then(liked => ({ id: item.id, liked }))  // Transform response to include item ID
    )
    
    // Wait for all promises to resolve
    Promise.all(promises)
      .then(results => {
        // Convert array of results to a lookup object by ID
        const newStatuses: Record<string, boolean> = {}
        results.forEach(result => {
          newStatuses[result.id] = result.liked  // e.g., { "123": true, "456": false }
        })
        setLikeStatuses(newStatuses)  // Update state with all statuses
        setLoading(false)  // Set loading to false
      })
      .catch(error => {
        console.error('Error checking batch like status:', error)
        setLoading(false)  // Ensure loading is set to false even on error
      })
  }, [items, entityType, isAuthenticated])  // Re-run when these dependencies change
  
  // Return both the statuses object and loading state
  return { likeStatuses, loading }
}
```

#### Detailed Explanation of Batch Hooks:

1. **Imports**:
   ```typescript
   import { useState, useEffect } from 'react'
   import { checkLikeStatus } from '@/api/likes'
   import { getToken } from '@/api/auth'
   ```
   - React hooks for state and side effects
   - API function for checking like status
   - Auth utility for checking if user is logged in

2. **Hook Function Declaration**:
   ```typescript
   export function useBatchLikeStatus(items: any[], entityType: string) {
     // Hook implementation...
   }
   ```
   - Custom React hook that follows the "use" naming convention
   - Takes an array of items and the entity type as parameters
   - Returns an object with like statuses and loading state

3. **State Initialization**:
   ```typescript
   const [likeStatuses, setLikeStatuses] = useState<Record<string, boolean>>({})
   const [loading, setLoading] = useState(true)
   ```
   - `likeStatuses` - Object mapping item IDs to boolean liked status
   - `loading` - Boolean tracking if API requests are in progress
   - TypeScript generic `Record<string, boolean>` defines the shape of the statuses object

4. **Effect Hook with Dependencies**:
   ```typescript
   useEffect(() => {
     // Effect implementation...
   }, [items, entityType])
   ```
   - Runs when component mounts and when dependencies change
   - Dependencies array ensures effect reruns when items or entity type changes

5. **Early Return Pattern**:
   ```typescript
   // Skip API calls if no items or not authenticated
   const token = getToken()
   if (!token || !items.length) {
     setLoading(false)
     return
   }
   ```
   - Optimization to avoid unnecessary API calls
   - Sets loading to false and returns early if conditions aren't met

6. **Promise.all for Parallel Requests**:
   ```typescript
   // Create an array of promises, one for each item
   const promises = items.map(item => 
     checkLikeStatus(entityType, item.id)
       .then(liked => ({ id: item.id, liked }))
   )
   
   // Wait for all promises to resolve
   Promise.all(promises)
     .then(/* ... */)
     .catch(/* ... */)
   ```
   - Maps each item to a promise that checks its like status
   - Uses `Promise.all` to wait for all requests to complete in parallel
   - More efficient than sequential requests

7. **Result Processing**:
   ```typescript
   .then(results => {
     // Convert array of results to a lookup object by ID
     const newStatuses: Record<string, boolean> = {}
     results.forEach(result => {
       newStatuses[result.id] = result.liked
     })
     setLikeStatuses(newStatuses)
     setLoading(false)
   })
   ```
   - Transforms array of results into a lookup object for efficient access
   - Updates state with the new statuses
   - Sets loading to false when complete

8. **Error Handling**:
   ```typescript
   .catch(error => {
     console.error('Error checking batch like status:', error)
     setLoading(false)
   })
   ```
   - Logs error for debugging
   - Ensures loading state is set to false even on error

This custom hook demonstrates several advanced React patterns:
- Custom hook composition
- Efficient batch API requests
- Dependency array optimization
- Early return pattern
- Promise.all for parallel requests
- Error handling
- Loading state management

## Communication Flow

1. **Parent Component to LikeButton**:
   - Parent component (e.g., PostPage) fetches content data
   - It passes entityType, entityId, initialLikeCount, and initialLiked to LikeButton

2. **User Interaction**:
   - User clicks the LikeButton
   - handleLikeToggle function is called
   - Component performs optimistic update (changes UI immediately)

3. **Component to API**:
   - LikeButton calls likeEntity or unlikeEntity from the API service
   - API service makes HTTP request to backend with entity information
   - Authentication headers are automatically included

4. **API Response Handling**:
   - If API call succeeds, the optimistic update remains
   - If API call fails, the component reverts the optimistic update
   - Loading state prevents multiple clicks during API calls

5. **Batch Operations for Lists**:
   - List components use useBatchLikeStatus hook
   - Hook efficiently fetches like status for multiple items in parallel
   - Results are transformed into a lookup object for easy access

This frontend implementation provides a responsive user experience with immediate feedback while ensuring eventual consistency with the backend data. 

## Backend Flow

### 1. Controller
**File: `server/src/controllers/likeController.ts`**

```typescript
import { Request, Response } from 'express';  // Express types for request and response
import * as likeService from '../services/likeService';  // Import service functions

/**
 * Create a new like
 */
export const createLike = async (req: Request, res: Response) => {
  try {
    // Extract data from request body
    // req.body contains the JSON data sent in the POST request
    const { entity_type, entity_id } = req.body;  // Destructure to get specific fields
    
    // req.user is added by the authenticate middleware
    // It contains the authenticated user's information
    const userId = req.user.id;  // Get user ID from authenticated request
    
    // Validate input - ensure required fields are present
    // This prevents database errors from missing data
    if (!entity_type || !entity_id) {
      // Return early with 400 Bad Request status code
      // This follows REST conventions for invalid requests
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like already exists to prevent duplicates
    // This is a business logic check before attempting database write
    const existingLike = await likeService.getLike(userId, entity_type, entity_id);
    if (existingLike) {
      // Return 409 Conflict for already existing resource
      // This is the appropriate HTTP status for duplicate creation attempts
      return res.status(409).json({ message: 'Already liked' });
    }
    
    // Create like in database by calling service function
    // The controller delegates database operations to the service layer
    const like = await likeService.createLike(userId, entity_type, entity_id);
    
    // Update like count on the entity
    // This is a separate operation to maintain denormalized count fields
    await likeService.incrementLikeCount(entity_type, entity_id);
    
    // Return success response with created like data
    // 201 Created is the appropriate status for resource creation
    return res.status(201).json(like);
  } catch (error) {
    // Log error for debugging and monitoring
    // This helps with troubleshooting production issues
    console.error('Error in createLike:', error);
    
    // Return generic error to client
    // Avoid exposing internal error details to clients
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Delete a like
 */
export const deleteLike = async (req: Request, res: Response) => {
  try {
    // Extract data from request body
    // For DELETE requests with body, data is in req.body
    const { entity_type, entity_id } = req.body;
    
    // Get user ID from authenticated request
    // This ensures users can only delete their own likes
    const userId = req.user.id;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      // Return 400 Bad Request for invalid input
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like exists before attempting to delete
    // This prevents errors from trying to delete non-existent resources
    const existingLike = await likeService.getLike(userId, entity_type, entity_id);
    if (!existingLike) {
      // Return 404 Not Found for non-existent resource
      // This follows REST conventions for resources that don't exist
      return res.status(404).json({ message: 'Like not found' });
    }
    
    // Delete like from database by calling service function
    // Pass the like ID to the service for precise deletion
    await likeService.deleteLike(existingLike.id);
    
    // Update like count on the entity
    // Maintain consistency of denormalized count fields
    await likeService.decrementLikeCount(entity_type, entity_id);
    
    // Return success response
    // 200 OK is appropriate for successful deletion
    return res.status(200).json({ message: 'Like removed' });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in deleteLike:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Check if a user has liked an entity
 */
export const getLikeStatus = async (req: Request, res: Response) => {
  try {
    // Extract data from query parameters
    // For GET requests, data is in req.query (from URL parameters)
    // e.g., /likes/status?entity_type=post&entity_id=123
    const { entity_type, entity_id } = req.query;
    
    // Get user ID from authenticated request
    // This is needed to check if this specific user has liked the content
    const userId = req.user.id;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if like exists in database
    // Type assertions (as string) are needed because req.query values are considered
    // potentially undefined or string[] by TypeScript
    const existingLike = await likeService.getLike(
      userId, 
      entity_type as string,
      entity_id as string
    );
    
    // Return boolean indicating if like exists
    // The !! operator converts the object/null to a boolean
    // This simplifies the response for the frontend
    return res.json({ liked: !!existingLike });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in getLikeStatus:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (req: Request, res: Response) => {
  try {
    // Extract data from query parameters
    // This endpoint is public, so no user ID is needed
    const { entity_type, entity_id } = req.query;
    
    // Validate input - ensure required fields are present
    if (!entity_type || !entity_id) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Get like count from database
    // Call service function with type assertions for query parameters
    const count = await likeService.getLikeCount(
      entity_type as string,
      entity_id as string
    );
    
    // Return count in response
    // Wrap the count in an object for consistent JSON response format
    return res.json({ count });
  } catch (error) {
    // Log error and return server error response
    console.error('Error in getLikeCount:', error);
    return res.status(500).json({ message: 'Server error' });
  }
};
```

### 2. Service
**File: `server/src/services/likeService.ts`**

```typescript
import { prisma } from '../lib/prisma';  // Import Prisma client for database operations

/**
 * Create a new like
 */
export const createLike = async (userId: string, entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Creating like: user=${userId}, type=${entityType}, id=${entityId}`);
  
  // Create like record in database using Prisma's create method
  // This generates and executes an SQL INSERT statement behind the scenes
  // When this executes, Prisma:
  // 1. Prepares the data with user_id, entity_type, and entity_id
  // 2. Automatically generates a UUID for the id field (from @default(uuid()) in schema)
  // 3. Sets created_at to current timestamp (from @default(now()) in schema)
  // 4. Generates and executes an SQL INSERT statement
  // 5. Returns the complete record with all fields populated
  const like = await prisma.likes.create({  // This line initiates the database operation
    data: {                                 // The data object specifies what to insert
      user_id: userId,                      // User performing the like
      entity_type: entityType,              // Type of content being liked
      entity_id: entityId                   // ID of the content being liked 
    }
  });  // The await keyword pauses execution until the database operation completes
  
  // Log success
  console.log(`[LIKE SERVICE] Like created successfully: ${like.id}`);
  return like;  // Return created like object with generated ID and other fields
};

/**
 * Delete a like
 */
export const deleteLike = async (likeId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Deleting like: id=${likeId}`);
  
  // Delete like record from database using Prisma's delete method
  // When this executes, Prisma:
  // 1. Generates an SQL DELETE statement with a WHERE clause for the ID
  // 2. Executes the statement against the database
  // 3. Returns the deleted record (which was fetched before deletion)
  const deletedLike = await prisma.likes.delete({  // This initiates the database deletion
    where: { id: likeId }  // Specifies which record to delete by primary key
  });  // The await keyword pauses execution until deletion completes
  
  // Log success
  console.log(`[LIKE SERVICE] Like deleted successfully: ${likeId}`);
  return deletedLike;  // Return deleted like object for potential use by caller
};

/**
 * Get a like by user, entity type, and entity ID
 */
export const getLike = async (userId: string, entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Checking like status: user=${userId}, type=${entityType}, id=${entityId}`);
  
  // Find like in database using Prisma's findFirst method
  // When this executes, Prisma:
  // 1. Generates an SQL SELECT statement with multiple WHERE conditions
  // 2. Executes the query against the database
  // 3. Returns the first matching record or null if none found
  const like = await prisma.likes.findFirst({  // This initiates the database query
    where: {                                   // The where object defines search criteria
      user_id: userId,                         // Must match this user
      entity_type: entityType,                 // Must match this content type
      entity_id: entityId                      // Must match this content ID
    }
  });  // The await keyword pauses execution until query completes
  
  // Log result
  console.log(`[LIKE SERVICE] Like status: ${like ? 'Liked' : 'Not liked'}`);
  return like;  // Return like object or null if not found
};

/**
 * Get the like count for an entity
 */
export const getLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Getting like count: type=${entityType}, id=${entityId}`);
  
  // Count likes in database using Prisma's count method
  // When this executes, Prisma:
  // 1. Generates an SQL COUNT query with WHERE conditions
  // 2. Executes the query against the database
  // 3. Returns just the count as a number
  const count = await prisma.likes.count({  // This initiates the counting operation
    where: {                                // The where object defines which likes to count
      entity_type: entityType,              // Must match this content type
      entity_id: entityId                   // Must match this content ID
    }
  });  // The await keyword pauses execution until count completes
  
  // Log result
  console.log(`[LIKE SERVICE] Like count: ${count}`);
  return count;  // Return the count as a number
};

/**
 * Increment the like count on an entity
 */
export const incrementLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Incrementing like count: type=${entityType}, id=${entityId}`);
  
  let result;
  // Update like count on the entity based on entity type
  switch (entityType) {
    case 'post':
      // When this executes, Prisma:
      // 1. Generates an SQL UPDATE statement with atomic increment
      // 2. Executes the update against the database
      // 3. Returns the updated post record
      result = await prisma.posts.update({        // This initiates the update operation
        where: { id: entityId },                  // Specifies which post to update
        data: { likes_count: { increment: 1 } }         // Uses atomic increment for thread safety
      });  // The await keyword pauses execution until update completes
      console.log(`[LIKE SERVICE] Post like count updated: ${result.likes_count}`);
      break;
    case 'article':
      // Similar process for articles table
      result = await prisma.articles.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which article to update
        data: { likes: { increment: 1 } }         // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Article like count updated: ${result.likes}`);
      break;
    case 'project':
      // Similar process for projects table, but different field name
      result = await prisma.projects.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which project to update
        data: { project_followers: { increment: 1 } }  // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Project followers count updated: ${result.project_followers}`);
      break;
    case 'comment':
      // Similar process for comments table, but different field name
      result = await prisma.comments.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which comment to update
        data: { likes_count: { increment: 1 } }   // Uses atomic increment for thread safety
      });
      console.log(`[LIKE SERVICE] Comment like count updated: ${result.likes_count}`);
      break;
    default:
      // Handle unknown entity types
      console.log(`[LIKE SERVICE] Unknown entity type: ${entityType}, no count updated`);
      return null;
  }
  
  return result;  // Return updated entity with new count
};

/**
 * Decrement the like count on an entity
 */
export const decrementLikeCount = async (entityType: string, entityId: string) => {
  // Log operation for debugging and monitoring
  console.log(`[LIKE SERVICE] Decrementing like count: type=${entityType}, id=${entityId}`);
  
  let result;
  // Update like count on the entity based on entity type
  switch (entityType) {
    case 'post':
      // When this executes, Prisma:
      // 1. Generates an SQL UPDATE statement with atomic decrement
      // 2. Executes the update against the database
      // 3. Returns the updated post record
      result = await prisma.posts.update({        // This initiates the update operation
        where: { id: entityId },                  // Specifies which post to update
        data: { likes_count: { decrement: 1 } }         // Uses atomic decrement for thread safety
      });  // The await keyword pauses execution until update completes
      console.log(`[LIKE SERVICE] Post like count updated: ${result.likes_count}`);
      break;
    case 'article':
      // Similar process for articles table
      result = await prisma.articles.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which article to update
        data: { likes: { decrement: 1 } }         // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Article like count updated: ${result.likes}`);
      break;
    case 'project':
      // Similar process for projects table, but different field name
      result = await prisma.projects.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which project to update
        data: { project_followers: { decrement: 1 } }  // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Project followers count updated: ${result.project_followers}`);
      break;
    case 'comment':
      // Similar process for comments table, but different field name
      result = await prisma.comments.update({     // This initiates the update operation
        where: { id: entityId },                  // Specifies which comment to update
        data: { likes_count: { decrement: 1 } }   // Uses atomic decrement for thread safety
      });
      console.log(`[LIKE SERVICE] Comment like count updated: ${result.likes_count}`);
      break;
    default:
      // Handle unknown entity types
      console.log(`[LIKE SERVICE] Unknown entity type: ${entityType}, no count updated`);
      return null;
  }
  
  return result;  // Return updated entity with new count
};
```

### 3. Routes
**File: `server/src/routes/likeRoutes.ts`**

```typescript
import { Router } from 'express';  // Express router for defining routes
import * as likeController from '../controllers/likeController';  // Import controller functions
import { authenticate } from '../middlewares/auth';  // Import auth middleware

// Create a new router instance
const router = Router();

// Protected routes (require authentication)
router.post('/', authenticate, likeController.createLike);  // Create like endpoint
router.delete('/', authenticate, likeController.deleteLike);  // Delete like endpoint
router.get('/status', authenticate, likeController.getLikeStatus);  // Check like status endpoint

// Public routes (no authentication required)
router.get('/count', likeController.getLikeCount);  // Get like count endpoint

export default router;  // Export router for use in main app
```

### 4. Main Router
**File: `server/src/routes/index.ts`**

```typescript
import likeRoutes from './likeRoutes';  // Import like routes

// Add this line where you define your routes
router.use('/likes', likeRoutes);  // Mount like routes under /likes path
```

### 5. Database Schema
**File: `server/prisma/schema.prisma`**

```prisma
model likes {
  id          String   @id @default(uuid())  // Unique identifier with auto-generated UUID
  user_id     String   // ID of user who performed the like
  entity_type String   // Type of content being liked (post, article, etc.)
  entity_id   String   // ID of the content being liked

  created_at  DateTime @default(now())  // Timestamp when like was created

  // Relation to users table
  users       users?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("likes")  // Maps to "likes" table in database
}
```

## Complete Request Flow

### Like Creation Flow

1. **Frontend Initiates Request**:
   - User clicks like button on a post
   - LikeButton component calls `likeEntity("post", "123")`
   - API service makes POST request to `/likes` with entity data

2. **Backend Route Handling**:
   - Request hits `router.post('/', authenticate, likeController.createLike)`
   - `authenticate` middleware verifies user is logged in and adds user to request
   - Request is passed to `createLike` controller function

3. **Controller Processing**:
   - Controller extracts data from request
   - Validates required fields are present
   - Checks if like already exists to prevent duplicates
   - Calls service functions to create like and update count

4. **Service Database Operations**:
   - `createLike` service creates record in likes table
   - `incrementLikeCount` service updates count on the entity
   - Both operations log details for monitoring

5. **Response Flow**:
   - Service returns created like to controller
   - Controller sends JSON response with 201 status
   - Frontend receives response
   - If successful, optimistic UI update remains
   - If error occurs, UI reverts to previous state

### Like Status Check Flow

1. **Frontend Initiates Request**:
   - Component mounts and needs to know if user has liked content
   - API service makes GET request to `/likes/status?entity_type=post&entity_id=123`

2. **Backend Route Handling**:
   - Request hits `router.get('/status', authenticate, likeController.getLikeStatus)`
   - `authenticate` middleware verifies user and adds user to request
   - Request is passed to `getLikeStatus` controller function

3. **Controller Processing**:
   - Controller extracts entity data from query parameters
   - Validates required fields are present
   - Calls service function to check if like exists

4. **Service Database Operation**:
   - `getLike` service queries database for matching like
   - Returns like object or null

5. **Response Flow**:
   - Controller converts result to boolean and sends JSON response
   - Frontend receives response and updates UI accordingly

This backend implementation works seamlessly with the frontend to provide a complete likes functionality across different content types, with proper authentication, validation, and error handling at each step. 